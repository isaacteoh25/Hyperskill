import sys
import runpy
import os
import importlib
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, Future, TimeoutError
from typing import List, Any, Dict, Tuple
from hstest.utils import failed, passed
from hstest.test_case import TestCase
from hstest.check_result import CheckResult
from hstest.exceptions import *
from hstest.outcomes import Outcome
from hstest.dynamic.handle import SystemHandler
from hstest.dynamic.handle_stdout import StdoutHandler
from hstest.dynamic.handle_stdin import StdinHandler
from hstest.test_run import TestRun


class StageTest:
    def __init__(self, module_to_test: str):
        self.module_to_test = module_to_test
        self.this_test_file = __file__
        self.file_to_test = module_to_test.replace('.', os.sep) + '.py'
        self.full_file_to_test = ''
        self.need_reload = True

    def reset(self):
        top_module = self.module_to_test[:self.module_to_test.rindex('.')]
        for name, module in list(sys.modules.items()):
            if name.startswith(top_module):
                importlib.reload(module)

    @staticmethod
    def create_files(files: Dict[str, str]):
        for file, content in files.items():
            with open(file, 'w') as f:
                f.write(content)

    @staticmethod
    def delete_files(files: Dict[str, str]):
        for file in files.keys():
            if os.path.isfile(file):
                os.remove(file)

    def run(self):
        runpy.run_module(
            self.module_to_test,
            run_name="__main__"
        )

    def generate(self) -> List[TestCase]:
        raise FatalErrorException('Can\'t create tests: override "generate" method')

    def check(self, reply: str, attach: Any) -> CheckResult:
        raise FatalErrorException('Can\'t check result: override "check" method')

    def after_all_tests(self):
        pass

    def _exec_file(self, args: List[str]):
        if self.need_reload:
            try:
                self.reset()
            except BaseException as ex:
                TestRun.curr_test_run.error_in_test = ex
        try:
            sys.argv = [self.file_to_test] + args
            runpy.run_module(
                self.module_to_test,
                run_name="__main__"
            )
        except ImportError as ex:
            TestRun.curr_test_run.error_in_test = FatalErrorException(
                f'Cannot find file {self.file_to_test}', ex)
        except SyntaxError as ex:
            TestRun.curr_test_run.error_in_test = SyntaxException(
                ex, self.file_to_test)
        except BaseException as ex:
            if TestRun.curr_test_run.error_in_test is None:
                # ExitException is thrown in case of exit() or quit()
                # consider them like normal exit
                if not isinstance(ex, ExitException):
                    TestRun.curr_test_run.error_in_test = ExceptionWithFeedback('', ex)

    def _run_file(self, args: List[str], time_limit: int):
        # Doesn't work with infinite loop
        # Probable solution - https://stackoverflow.com/a/44719580
        with ThreadPoolExecutor(max_workers=1) as executor:
            try:
                future: Future = executor.submit(lambda: self._exec_file(args))
                if time_limit <= 0:
                    future.result()
                else:
                    future.result(timeout=time_limit / 1000)
            except TimeoutError:
                TestRun.curr_test_run.error_in_test = TimeLimitException(time_limit)
            except BaseException as ex:
                TestRun.curr_test_run.error_in_test = ex

    def _run_test(self, test: TestCase) -> str:
        StdinHandler.set_input_funcs(test.input_funcs)
        StdoutHandler.reset_output()
        TestRun.curr_test_run.error_in_test = None

        self._run_file(test.args, test.time_limit)
        self._check_errors(test)

        return StdoutHandler.get_output()

    def _check_errors(self, test: TestCase):
        if TestRun.curr_test_run.error_in_test is None:
            return

        error_in_test = TestRun.curr_test_run.error_in_test
        if isinstance(error_in_test, TestPassedException):
            return

        if isinstance(error_in_test, ExceptionWithFeedback):
            user_exception = error_in_test.real_exception
            for exception, feedback in test.feedback_on_exception.items():
                ex_type = type(user_exception)
                if ex_type is not None and issubclass(ex_type, exception):
                    raise ExceptionWithFeedback(feedback, user_exception)

        raise error_in_test

    def _check_solution(self, test: TestCase, output: str):
        if isinstance(TestRun.curr_test_run.error_in_test, TestPassedException):
            return CheckResult.correct()
        if test.check_function is not None:
            return test.check_function(output, test.attach)
        else:
            return self.check(output, test.attach)

    def run_tests(self, debug=False) -> Tuple[int, str]:
        if debug:
            import hstest.utils as hs
            hs.failed_msg_start = ''
            hs.failed_msg_continue = ''
            hs.success_msg = ''

        curr_test: int = 0
        try:
            SystemHandler.set_up()
            tests = self.generate()
            if len(tests) == 0:
                raise FatalErrorException('No tests provided by "generate" method')

            for test in tests:
                curr_test += 1

                red_bold = '\033[1;31m'
                reset = '\033[0m'
                StdoutHandler.real_stdout.write(
                    red_bold + f'\nStart test {curr_test}' + reset + '\n'
                )

                TestRun.curr_test_run = TestRun(curr_test, test)

                self.create_files(test.files)

                output: str = self._run_test(test)
                result: CheckResult = self._check_solution(test, output)

                self.delete_files(test.files)

                if not result.result:
                    raise WrongAnswerException(result.feedback)

            return passed()

        except BaseException as ex:
            outcome: Outcome = Outcome.get_outcome(ex, self, curr_test)
            fail_text = str(outcome)
            return failed(fail_text)

        finally:
            StageTest.curr_test_run = None
            self.after_all_tests()
            SystemHandler.tear_down()

from hstest.stage_test import StageTest
from hstest.test_case import TestCase
from hstest.check_result import CheckResult
from threading import Thread
from time import sleep
import socket
import random
import json

CheckResult.correct = lambda: CheckResult(True, '')
CheckResult.wrong = lambda feedback: CheckResult(False, feedback)

abc = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'

logins_list = [
    'admin', 'Admin', 'admin1', 'admin2', 'admin3',
    'user1', 'user2', 'root', 'default', 'new_user',
    'some_user', 'new_admin', 'administrator',
    'Administrator', 'superuser', 'super', 'su', 'alex',
    'suser', 'rootuser', 'adminadmin', 'useruser',
    'superadmin', 'username', 'username1'
]


def logins():
    for login in logins_list:
        yield login


def random_password():
    '''function - generating random password of length from 6 to 10'''
    return ''.join(random.choice(abc) for i in range(random.randint(6, 10)))


def random_login():
    return random.choice(list(logins()))


class Hacking(StageTest):

    def __init__(self, module):
        super().__init__(module)
        self.ready = False
        self.sock = None
        self.serv = None
        self.connected = False
        self.message = []
        self.password = None
        self.login = None

    def start_server(self):
        self.serv = Thread(target=lambda: self.server())
        self.serv.start()
        self.ready = False
        while not self.ready:
            try:
                sleep(0.1)  # socket needs to be set up before test
            except KeyboardInterrupt:
                pass

    def stop_server(self):
        self.sock.close()
        self.serv.join()

    def server(self):
        '''function - creating a server and answering clients'''
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.sock.bind(('localhost', 9090))
        self.ready = True
        try:
            self.sock.listen(1)
            conn, addr = self.sock.accept()
            self.connected = True
            while True:
                data = conn.recv(1024)
                self.message.append(data.decode('utf8'))
                if len(self.message) > 1_000_000:
                    conn.send(
                        json.dumps({
                            'result': 'Too many attempts to connect!'
                        }).encode('utf8'))
                    break
                if not data:
                    break

                try:
                    login_ = json.loads(data.decode('utf8'))['login']
                    password_ = json.loads(data.decode('utf8'))['password']
                except:
                    conn.send(json.dumps({'result': 'Bad request!'}).encode('utf8'))
                    continue

                if login_ == self.login:
                    if self.password == password_:
                        conn.send(
                            json.dumps({
                                'result': 'Connection success!'
                            }).encode('utf8'))
                        break
                    elif self.password.startswith(password_):
                        conn.send(
                            json.dumps({
                                'result': 'Exception happened during login'
                            }).encode('utf8'))
                    else:
                        conn.send(
                            json.dumps({
                                'result': 'Wrong password!'
                            }).encode('utf8'))
                else:
                    conn.send(json.dumps({'result': 'Wrong login!'}).encode('utf8'))
            conn.close()
        except:
            pass

    def generate(self):
        self.message = []
        self.password = random_password()
        self.login = random_login()
        self.start_server()
        return [
            TestCase(
                args=['localhost', '9090'],
                attach=[self.password, self.login]
            )
        ]

    def check(self, reply, attach):
        self.stop_server()

        if not self.connected:
            return CheckResult.wrong("You didn't connect to the server")

        real_password, real_login = attach
        try:
            json_reply = json.loads(reply)
        except:
            return CheckResult.wrong(
                'The output of your program is not a valid JSON:\n' + reply
            )
        password = json_reply['password']
        login = json_reply['login']
        if login != real_login:
            return CheckResult.wrong('The login you printed is not correct')
        elif password != real_password:
            return CheckResult.wrong('The password you printed is not correct')
        find_first_letter = False
        for i in self.message:
            log = json.loads(i)['login']
            pas = json.loads(i)['password']
            if find_first_letter is False and len(
                    pas
            ) == 1 and log == real_login and real_password.startswith(pas):
                find_first_letter = True
            if find_first_letter is True:
                if log != real_login:
                    return CheckResult.wrong(
                        'You should find a correct login and then use only it')
                if pas[0] != real_password[0]:
                    return CheckResult.wrong(
                        'When you find a first letter you should then start your passwords with it'
                    )
            if len(pas) > 1:
                if pas[0:-1] != real_password[0:len(pas[0:-1]) - 1]:
                    return CheckResult.wrong(
                        'You have already found the first %d letters of the password. Use them as a beginning'
                        % len(pas[0:-1]))
            return CheckResult.correct()


if __name__ == '__main__':
    test = Hacking('hacking.hack')
    test.run_tests()
    test.stop_server()
			
