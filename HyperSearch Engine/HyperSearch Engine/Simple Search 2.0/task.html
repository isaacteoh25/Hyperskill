<h2>Description</h2>

<p>In this stage, complete the following steps:</p>

<ol>
	<li> Learn how to make context windows out of a dictionary with positions;</li>
	<li> Combine the first step with the features from the previous stages. The program should return windows, processed as in the previous stage.</li>
</ol>

<h2>Objectives</h2>

<p>Your program is given a folder with files. The program processes them and returns a dictionary with context windows. Then these windows should be converted into a dictionary with combined and expanded windows with their number adjusted by limit and offset.</p>

<p>In more detail, it should do the following:</p>

<ol>
	<li>Take an input that consists of a dictionary, a query, a window size, a limit, and an offset: <code class="java">input_dictionary,query='man', window_size=1, limit=1, offset=0</code>.</li>
	<li>A dictionary can look like this: <code class="java">{'filename.txt': [first_position, second_position, ...]}</code> , it is the result of the search. Note that the context window size remains constant;</li>
	<li>Iterate over all positions in each file;</li>
	<li>Create a context window from each position;</li>
	<li>Save context windows in a corresponding dictionary: <code class="java">{'filename.txt': [window1, window2, ...]}</code>;</li>
	<li>Extend all windows to match sentences;</li>
	<li>Test whether the windows overlap. If so, merge them into one and save only the result of merging. Note that before this step you worked only with two windows that either overlapped or not. Now, you have a dictionary with a lot of windows, so you should iterate over the dictionary, taking two consecutive windows each time to check whether they overlap or not. If they do not overlap, take the next two consecutive windows and repeat the action;</li>
	<li>Save the results in the output dictionary: <code class="java">{'filename.txt': [window1, window2, ...]}</code>. Do not forget that you need to save as many files with their context window lists as indicated in the limit. Start from the index of the result that is indicated in the offset; see the example below;</li>
	<li>Sort the dictionary in ascending order and print the result in the following format: <code class="java">filename_1: list with windows_1\nfilename_2: list with windows_2</code></li>
	<li>Clear the database after indexing</li>
</ol>

<h2>Examples</h2>

<p>The greater-than symbol followed by a space (<code class="java">&gt; </code>) represents the user input. Note that it's not part of the input.</p>

<p>During tests, you are given a test folder. Input is a folder path, where you need to find and process all text files. Your program should take this path and iterate over files. Clear your database after each test.</p>

<p><strong>Example 1</strong>:</p>

<p>Folder contents: <em>testfile1.txt, testfile2.txt.</em></p>

<p><em>testfile1.txt </em>contents:<br>
<code class="java">It seemed a delightful prospect. This man evidently understands my complaint.</code></p>

<p><em>testfile2.txt </em>contents:<br>
<code class="java">Every possible situation man could imagine has been spoilt.</code></p>

<p>Output:</p>

<pre><code class="language-no-highlight">&gt; tests/stage6/ex1
&gt; 'man',1,1,0
testfile1.txt: ['It seemed a delightful prospect. This man evidently understands my complaint.|[[0, 38, 41]]|33|78']</code></pre>

<p><strong>Example 2</strong>:</p>

<p>Folder contents: <em>testfile3.txt</em>.</p>

<p><em>testfile3.txt </em>contents:</p>

<pre><code class="language-no-highlight">There’s enough water to see, right?
To tell the truth, it was water from the river, too.</code></pre>

<p>Output: </p>

<pre><code class="language-no-highlight">&gt; tests/stage6/ex2
&gt; 'water',1,2,0
testfile3.txt: ['There’s enough water to see, right?|[[0, 15, 20]]|0|36', 'To tell the truth, it was water from the river, too.|[[1, 26, 31]]|0|53']</code></pre>