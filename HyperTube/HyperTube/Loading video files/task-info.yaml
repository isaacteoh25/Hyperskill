type: edu
files:
- name: hypertube/tube/admin.py
  visible: true
  text: |
    from django.contrib import admin

    # Register your models here.
  learner_created: false
- name: hypertube/tube/tests.py
  visible: true
  text: |
    from django.test import TestCase

    # Create your tests here.
  learner_created: false
- name: hypertube/tube/views.py
  visible: true
  text: |
    from django.shortcuts import render

    # Create your views here.
  learner_created: false
- name: hypertube/tube/models.py
  visible: true
  text: |
    from django.db import models

    # Create your models here.
  learner_created: false
- name: hypertube/tube/migrations/__init__.py
  visible: true
  learner_created: false
- name: hypertube/tube/__init__.py
  visible: true
  learner_created: false
- name: hypertube/hypertube/urls.py
  visible: true
  text: |
    """hypertube URL Configuration

    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/2.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path

    urlpatterns = [
        path('admin/', admin.site.urls),
    ]
  learner_created: false
- name: hypertube/hypertube/wsgi.py
  visible: true
  text: |
    """
    WSGI config for hypertube project.

    It exposes the WSGI callable as a module-level variable named ``application``.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/
    """

    import os

    from django.core.wsgi import get_wsgi_application

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hypertube.settings')

    application = get_wsgi_application()
  learner_created: false
- name: hypertube/hypertube/__init__.py
  visible: true
  learner_created: false
- name: hypertube/hypertube/settings.py
  visible: true
  text: |
    """
    Django settings for hypertube project.

    Generated by 'django-admin startproject' using Django 2.2.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/2.2/ref/settings/
    """

    import os

    # Build paths inside the project like this: os.path.join(BASE_DIR, ...)
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = '_(l+b!c#@bx)kksgr$(zoh#!q8e8vxt4e&g&8gca_uu#h40i4z'

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = []


    # Application definition

    INSTALLED_APPS = [
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'tube.apps.TubeConfig',
    ]

    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ROOT_URLCONF = 'hypertube.urls'

    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]

    WSGI_APPLICATION = 'hypertube.wsgi.application'


    # Database
    # https://docs.djangoproject.com/en/2.2/ref/settings/#databases

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.environ.get('HYPERSKILL_TEST_DATABASE') or os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }


    # Password validation
    # https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/2.2/topics/i18n/

    LANGUAGE_CODE = 'en-us'

    LOGIN_REDIRECT_URL = '/tube/'

    TIME_ZONE = 'UTC'

    USE_I18N = True

    USE_L10N = True

    USE_TZ = True


    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/2.2/howto/static-files/

    STATIC_URL = '/static/'

    # MEDIA
    MEDIA_ROOT = os.environ.get('HYPERSKILL_MEDIA_ROOT') or os.path.join(BASE_DIR, 'media/')
    MEDIA_URL = '/media/'
  learner_created: false
- name: hypertube/manage.py
  visible: true
  text: |
    #!/usr/bin/env python
    """Django's command-line utility for administrative tasks."""
    import os
    import sys


    def main():
        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hypertube.settings')
        try:
            from django.core.management import execute_from_command_line
        except ImportError as exc:
            raise ImportError(
                "Couldn't import Django. Are you sure it's installed and "
                "available on your PYTHONPATH environment variable? Did you "
                "forget to activate a virtual environment?"
            ) from exc
        execute_from_command_line(sys.argv)


    if __name__ == '__main__':
        main()
  learner_created: false
- name: hypertube/tube/apps.py
  visible: true
  text: |
    from django.apps import AppConfig


    class TubeConfig(AppConfig):
        name = 'tube'
  learner_created: false
- name: base.py
  visible: false
  text: |
    # -*- coding: utf-8 -*-
    import http.cookiejar
    import io
    import os
    import re
    import sqlite3
    import urllib

    import requests

    from hstest.django_test import DjangoTest, TEST_DATABASE
    from hstest.check_result import CheckResult

    UPLOADING_FILE_NAME = 'test_video.mp4'

    with open(UPLOADING_FILE_NAME, 'rb') as f:
        test_video_data = f.read()

    CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))

    INITIAL_TAGS = [
        (1, 'sport'),
        (2, 'snake'),
        (3, 'waves'),
    ]

    INITIAL_VIDEOS = [
        (1, 'surf.mp4', 'surfing'),
        (2, 'tai.mp4', 'tai'),
    ]

    INITIAL_VIDEOTAGS = [
        (1, 1, 1),
        (2, 2, 2),
        (3, 3, 1),
    ]


    class HyperTubeTest(DjangoTest):
        COMMON_LINK_PATTERN = '''<a[^>]+href=['"]([a-zA-Z\d/_]+)['"][^>]*>'''
        CSRF_PATTERN = b'<input[^>]+name="csrfmiddlewaretoken" ' \
                       b'value="(?P<csrf>\w+)"[^>]*>'
        GROUPS_FIRST_PATTERN = '<h4>.*?</h4>.*?<ul>.+?</ul>'
        GROUPS_SECOND_PATTERN = (
            '''<a[^>]+href=['"]([a-zA-Z\d/_]+)['"][^>]*>(.+?)</a>'''
        )
        H2_PATTERN = '<h2>(.+?)</h2>'
        LINK_WITH_TEXT_PATTERN = '''<a[^>]+href=['"]([a-zA-Z\d/_?=]+)['"][^>]*>(.+?)</a>'''
        PARAGRAPH_PATTERN = '<p>(.+?)</p>'
        SRC_PATTERN = '''<source[^>]+src=['"]([a-zA-Z\d/_.]+)['"][^>]*>'''
        TEXT_LINK_PATTERN = '''<a[^>]+href=['"][a-zA-Z\d/_]+['"][^>]*>(.+?)</a>'''
        cookie_jar = http.cookiejar.CookieJar()
        USERNAME = 'Test'
        PASSWORD = 'TestPassword123'
        TAG = 'testtag'
        TITLE = 'Test Video'

        def __init__(self, *args, **kwargs):
            os.environ['HYPERSKILL_MEDIA_ROOT'] = CURRENT_DIR
            file_and_dir_names = os.listdir(CURRENT_DIR)
            file_name_without_extension = UPLOADING_FILE_NAME.split('.')[0]
            for name in file_and_dir_names:
                if file_name_without_extension in name:
                    self.__delete_file(name)

            super().__init__(*args, **kwargs)

        def __delete_file(self, name):
            file_path = os.path.join(CURRENT_DIR, name)
            if name != UPLOADING_FILE_NAME and os.path.exists(file_path):
                os.remove(file_path)

        def check_create_videos(self) -> CheckResult:
            connection = sqlite3.connect(TEST_DATABASE)
            cursor = connection.cursor()
            try:
                cursor.executemany(
                    'INSERT INTO tube_tag (`id`, `name`) VALUES (?, ?)',
                    INITIAL_TAGS
                )
                cursor.executemany(
                    'INSERT INTO tube_video (`id`,`file`, `title`) '
                    'VALUES (?, ?, ?)',
                    INITIAL_VIDEOS
                )
                cursor.executemany(
                    'INSERT INTO tube_videotag (`id`,`tag_id`, `video_id`) '
                    'VALUES (?, ?, ?)',
                    INITIAL_VIDEOTAGS
                )
                connection.commit()

                cursor.execute(
                    'SELECT `id`, `name` FROM tube_tag')
                tags = cursor.fetchall()

                if tags != INITIAL_TAGS:
                    return CheckResult.false('Check your Tag model')

                cursor.execute(
                    'SELECT `id`,`file`, `title` FROM tube_video')
                videos = cursor.fetchall()

                if videos != INITIAL_VIDEOS:
                    return CheckResult.false('Check your Video model')

                cursor.execute(
                    'SELECT `id`,`tag_id`, `video_id` FROM tube_videotag')
                videotags = cursor.fetchall()

                if videotags != INITIAL_VIDEOTAGS:
                    return CheckResult.false('Check your VideoTag model')

                return CheckResult.true()
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

        def check_main_header(self) -> CheckResult:
            try:
                page = self.read_page(f'http://localhost:{self.port}/tube/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            h2_headers = re.findall(self.H2_PATTERN, page, re.S)
            h2_headers = self.__stripped_list(h2_headers)
            main_header = 'Hypertube'

            is_main_header = False
            for h2_header in h2_headers:
                if main_header in h2_header:
                    is_main_header = True
                    break

            if not is_main_header:
                return CheckResult.false(
                    'Main page should contain <h2> element with text "Hypertube"'
                )

            return CheckResult.true()

        def check_main_page_login_link(self):
            login_link = '/login/'
            try:
                page = self.read_page(f'http://localhost:{self.port}/tube/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if login_link not in links_from_page:
                return CheckResult.false(
                    f'Main page should contain <a> element with href {login_link}'
                )

            return CheckResult.true()

        def check_main_page_upload_link(self):
            upload_link = '/tube/upload/'
            try:
                page = self.read_page(f'http://localhost:{self.port}/tube/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if upload_link not in links_from_page:
                return CheckResult.false(
                    f'Main page should contain <a> element with href {upload_link}'
                )

            return CheckResult.true()

        def check_main_page_video_links(self):
            connection = sqlite3.connect(TEST_DATABASE)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    'SELECT `id`, `title` FROM tube_video')
                videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

            video_links_with_titles_from_db = [(f'/tube/watch/{x[0]}/',
                                                x[1]) for x in videos]

            try:
                page = self.read_page(f'http://localhost:{self.port}/tube/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.LINK_WITH_TEXT_PATTERN, page, re.S)
            links_from_page = self.__stripped_list_with_tuple(links_from_page)

            for video_link in video_links_with_titles_from_db:
                if video_link not in links_from_page:
                    return CheckResult.false(
                        'Main page should contain <a> element with href '
                        '/tube/watch/{id}/ and title as link text'
                    )

            return CheckResult.true()

        def check_main_page_video_count(self):
            connection = sqlite3.connect(TEST_DATABASE)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    'SELECT count(*) FROM tube_video')
                video_count = str(cursor.fetchall()[0][0])
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

            try:
                page = self.read_page(f'http://localhost:{self.port}/tube/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            paragraphs_from_page = re.findall(self.PARAGRAPH_PATTERN, page, re.S)
            paragraphs_from_page = self.__stripped_list(paragraphs_from_page)

            quantity_in_paragraphs = False
            for paragraph in paragraphs_from_page:
                if video_count in paragraph:
                    quantity_in_paragraphs = True
                    break

            if not quantity_in_paragraphs:
                return CheckResult.false(
                    f'Main page should contain <p> element with quantity of videos'
                )

            return CheckResult.true()

        def __stripped_list(self, list):
            return [item.strip() for item in list]

        def __stripped_list_with_tuple(self, list):
            return [(item[0].strip(), item[1].strip()) for item in list]

        def check_main_page_search(self):
            q = 'ai'
            connection = sqlite3.connect(TEST_DATABASE)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    f"SELECT `id`, `title` FROM tube_video WHERE title "
                    f"LIKE '%{q}%'"
                )
                visible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

            visible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in visible_videos]

            try:
                cursor.execute(
                    f"SELECT `id`, `title` FROM tube_video WHERE title "
                    f"NOT LIKE '%{q}%'"
                )
                invisible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

            invisible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in invisible_videos]

            try:
                page = self.read_page(f'http://localhost:{self.port}/tube/?q={q}')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.LINK_WITH_TEXT_PATTERN, page, re.S)
            links_from_page = self.__stripped_list_with_tuple(links_from_page)

            for video_link in visible_video_links_with_titles_from_db:
                if video_link not in links_from_page:
                    return CheckResult.false(
                        'Main page should contain links with found videos '
                        'when searching'
                    )

            for video_link in invisible_video_links_with_titles_from_db:
                if video_link in links_from_page:
                    return CheckResult.false(
                        f'Main page should not contain links with unfound videos '
                        f'when searching'
                    )

            return CheckResult.true()

        def check_main_page_tag_filtering(self):
            tag = 'sport'
            connection = sqlite3.connect(TEST_DATABASE)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    f"SELECT tube_video.id, tube_video.title FROM tube_video "
                    f"JOIN tube_videotag ON tube_video.id = tube_videotag.video_id "
                    f"JOIN tube_tag ON tube_videotag.tag_id = tube_tag.id "
                    f"WHERE tube_tag.name = '{tag}'"
                )
                visible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

            visible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in visible_videos]

            try:
                cursor.execute(
                    f"SELECT tv.id, tv.title FROM tube_video tv "
                    f"WHERE NOT EXISTS (SELECT 1 FROM tube_video "
                    f"JOIN tube_videotag ON tube_video.id = tube_videotag.video_id "
                    f"JOIN tube_tag ON tube_videotag.tag_id = tube_tag.id "
                    f"WHERE tube_tag.name = '{tag}' AND tv.id = tube_video.id)"
                )
                invisible_videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

            invisible_video_links_with_titles_from_db = \
                [(f'/tube/watch/{x[0]}/', x[1]) for x in invisible_videos]

            try:
                page = self.read_page(
                    f'http://localhost:{self.port}/tube/?tag={tag}'
                )
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the main page.'
                )

            links_from_page = re.findall(self.LINK_WITH_TEXT_PATTERN, page, re.S)
            links_from_page = self.__stripped_list_with_tuple(links_from_page)

            for video_link in visible_video_links_with_titles_from_db:
                if video_link not in links_from_page:
                    return CheckResult.false(
                        'Main page should contain links with found videos when '
                        'filtering with tags'
                    )

            for video_link in invisible_video_links_with_titles_from_db:
                if video_link in links_from_page:
                    return CheckResult.false(
                        'Main page should not contain links with unfound videos '
                        'when filtering with tags'
                    )

            return CheckResult.true()

        def check_signup(self) -> CheckResult:
            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar)
            )
            try:
                response = opener.open(f'http://localhost:{self.port}/signup/')
            except urllib.error.URLError:
                return CheckResult.false('Cannot connect to the signup page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.false('Missing csrf_token in the form')

            try:
                response = opener.open(
                    f'http://localhost:{self.port}/signup/',
                    data=urllib.parse.urlencode({
                        'csrfmiddlewaretoken': csrf_options[0],
                        'username': self.USERNAME,
                        'password1': self.PASSWORD,
                        'password2': self.PASSWORD,
                    }).encode()
                )
                if f'login' in response.url:
                    return CheckResult.true()
                return CheckResult.false('Cannot signup: problems with form')
            except urllib.error.URLError as err:
                return CheckResult.false(f'Cannot signup: {err.reason}')

        def check_login(self) -> CheckResult:
            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                response = opener.open(f'http://localhost:{self.port}/login/')
            except urllib.error.URLError:
                return CheckResult.false('Cannot connect to the login page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.false('Missing csrf_token in the form')

            try:
                response = opener.open(
                    f'http://localhost:{self.port}/login/',
                    data=urllib.parse.urlencode({
                        'csrfmiddlewaretoken': csrf_options[0],
                        'username': self.USERNAME,
                        'password': self.PASSWORD,
                    }).encode(),
                )
                if 'login' not in response.url:
                    return CheckResult.true()
                return CheckResult.false('Cannot login: problems with form')
            except urllib.error.URLError as err:
                return CheckResult.false(f'Cannot login: {err.reason}')

        def check_uploading_video(self):
            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                upload_page_response = opener.open(
                    f'http://localhost:{self.port}/tube/upload/')
            except urllib.error.URLError:
                return CheckResult.false('Cannot connect to the upload page.')

            upload_page = upload_page_response.read()

            csrf_options = re.findall(self.CSRF_PATTERN, upload_page)

            if not csrf_options:
                return CheckResult.false(
                    'Missing csrf_token in the upload page form')

            new_video = {
                'title': self.TITLE,
                'tags': self.TAG,
                'csrfmiddlewaretoken': csrf_options[0],
            }
            files = {'video': open(UPLOADING_FILE_NAME, 'rb')}

            upload_response = requests.post(
                f'http://localhost:{self.port}/tube/upload/',
                cookies=self.cookie_jar, files=files, data=new_video
            )

            if upload_response.url != f'http://localhost:{self.port}/tube/':
                return CheckResult.false(
                    'After uploading video handler should redirects to the /tube/ '
                    'page')

            connection = sqlite3.connect(TEST_DATABASE)
            cursor = connection.cursor()
            try:
                cursor.execute(
                    f"SELECT count(*) FROM tube_video WHERE title = '{self.TITLE}'"
                )
                videos = cursor.fetchall()
            except sqlite3.DatabaseError as err:
                return CheckResult.false(str(err))

            if videos[0][0] != 1:
                return CheckResult.false(
                    'After uploading video data doesn\'t saved in database')

            return CheckResult.true()

        def check_forbid_anonymous_upload(self) -> CheckResult:
            opener = urllib.request.build_opener()
            try:
                upload_page_response = opener.open(
                    f'http://localhost:{self.port}/tube/upload/')
            except urllib.error.URLError:
                return CheckResult.false('Cannot connect to the upload page.')

            upload_page = upload_page_response.read()

            csrf_options = re.findall(self.CSRF_PATTERN, upload_page)
            if not csrf_options:
                return CheckResult.true()

            title = 'Test Video'

            new_video = {
                'title': title,
                'tags': 'testtag',
                'csrfmiddlewaretoken': csrf_options[0],
            }
            files = {'video': open(UPLOADING_FILE_NAME, 'rb')}

            upload_response = requests.post(
                f'http://localhost:{self.port}/tube/upload/', files=files,
                data=new_video
            )

            if upload_response.status_code != 403:
                return CheckResult.false(
                    'Should not allow anonymous users upload video')

            return CheckResult.true()

        def check_upload_page_main_link(self):
            main_link = '/tube/'

            try:
                page = self.read_page(
                    f'http://localhost:{self.port}/tube/upload/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the upload page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, page, re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if main_link not in links_from_page:
                return CheckResult.false(
                    f'Upload page should contain <a> element with href {main_link}'
                )

            return CheckResult.true()

        def check_watch_and_video_response(self):
            video_template_link = '/tube/{file_name}/'
            login_link = '/login/'
            main_link = '/tube/'
            try:
                watch_response = self.read_page(
                    f'http://localhost:{self.port}/tube/watch/3/')
            except urllib.error.URLError:
                return CheckResult.false(
                    'Cannot connect to the watch page.'
                )

            links_from_page = re.findall(self.COMMON_LINK_PATTERN, watch_response,
                                         re.S)
            links_from_page = self.__stripped_list(links_from_page)

            if login_link not in links_from_page:
                return CheckResult.false(
                    f'Watch page should contain <a> element with href {login_link}'
                )
            if main_link not in links_from_page:
                return CheckResult.false(
                    f'Watch page should contain <a> element with href {main_link}'
                )

            paragraphs_from_page = re.findall(self.PARAGRAPH_PATTERN,
                                              watch_response, re.S)
            paragraphs_from_page = self.__stripped_list(paragraphs_from_page)
            if self.TITLE not in paragraphs_from_page:
                return CheckResult.false(
                    f'Watch page should contain <p> element with the video title'
                )

            links_with_text_from_page = re.findall(
                self.LINK_WITH_TEXT_PATTERN, watch_response, re.S)
            links_with_text_from_page = self.__stripped_list_with_tuple(
                links_with_text_from_page)

            video_link_with_text = (f'/tube/?tag={self.TAG}', f'#{self.TAG}')
            if video_link_with_text not in links_with_text_from_page:
                return CheckResult.false(
                    'Watch page should contain <a> element with href to '
                    '/tube/?tag={tag} filter and #{tag} as link text, where '
                    'tag is your tag name'
                )

            src_from_page = re.findall(self.SRC_PATTERN, watch_response, re.S)
            src_from_page = self.__stripped_list(src_from_page)
            video_link = None
            for src in src_from_page:
                if UPLOADING_FILE_NAME.split('.')[0] in src:
                    video_link = src
                    break

            if not video_link:
                return CheckResult.false(
                    f'Watch page should contain <source> element with src '
                    f'{video_template_link}'
                )
            file_name_to_delete = video_link.split('/')[-1]

            video_response = requests.get(
                f'http://localhost:{self.port}{video_link}/')

            required_header = {'Accept-Ranges': 'bytes'}

            if video_response.headers.get('Accept-Ranges') != 'bytes':
                self.__delete_file(file_name_to_delete)
                return CheckResult.false(
                    f'Video response should contain header {required_header}'
                )

            if video_response.headers.get('Content-Type') != 'video/mp4':
                self.__delete_file(file_name_to_delete)
                return CheckResult.false(
                    f'Video response should contain Content-Type header, '
                    f'e.g. Content-Type: video/mp4 for mp4 video'
                )

            response_file_bytes = io.BytesIO()
            for chunk in video_response.iter_content(chunk_size=1024):
                response_file_bytes.write(chunk)

            if response_file_bytes.getvalue() != test_video_data:
                self.__delete_file(file_name_to_delete)
                return CheckResult.false(
                    'Video response should contain uploaded file in bytes'
                )

            self.__delete_file(file_name_to_delete)
            return CheckResult.true()
  learner_created: false
- name: tests.py
  visible: false
  text: |
    # -*- coding: utf-8 -*-
    from hstest.test_case import TestCase

    from base import HyperTubeTest


    class HyperTubeTestRunner(HyperTubeTest):
        def generate(self):
            return [
                # 1 task
                TestCase(attach=self.check_server),
                TestCase(attach=self.check_create_videos),
                # 2 task
                TestCase(attach=self.check_main_header),
                TestCase(attach=self.check_main_page_login_link),
                TestCase(attach=self.check_main_page_upload_link),
                TestCase(attach=self.check_main_page_video_links),
                TestCase(attach=self.check_main_page_video_count),
                # 3 task
                TestCase(attach=self.check_main_page_search),
                TestCase(attach=self.check_main_page_tag_filtering),
                # 4 task
                TestCase(attach=self.check_signup),
                TestCase(attach=self.check_login),
                # 5 task
                TestCase(attach=self.check_uploading_video),
                TestCase(attach=self.check_forbid_anonymous_upload),
                TestCase(attach=self.check_upload_page_main_link),
            ]

        def check(self, reply, attach):
            return attach()


    if __name__ == '__main__':
        HyperTubeTestRunner('hypertube.manage').run_tests()
  learner_created: false
- name: hstest/__init__.py
  visible: false
  learner_created: false
- name: hstest/test_case.py
  visible: false
  text: |
    from typing import List, Dict, Any, Tuple, Callable


    class TestCase:

        def __init__(self, *, stdin='', args=None,
                     attach=None, files=None, copy_to_attach=False,
                     attach_callback=None):
            self.input: str = stdin
            self.args: List[str] = [] if args is None else args
            self.attach: Any = attach
            self.attach_callback: Callable = attach_callback
            self.files: Dict[str, str] = {} if files is None else files
            if copy_to_attach:
                self.attach = stdin

        @staticmethod
        def from_stepik(stepik_tests: List[Tuple[str, Any]]) -> List['TestCase']:
            hs_tests = []
            for test in stepik_tests:
                hs_test = TestCase()
                if type(test) in (list, tuple):
                    hs_test.input = test[0]
                    hs_test.attach = test[1]
                elif type(test) is str:
                    hs_test.input = test
                else:
                    raise ValueError("Bad test: " + str(test))
                hs_tests += [hs_test]
            return hs_tests
  learner_created: false
- name: hstest/exceptions.py
  visible: false
  text: |2

    class BadSolutionException(Exception):
        def __init__(self, message):
            self.message = message


    class SyntaxException(BadSolutionException):
        def __init__(self, message):
            super().__init__(message)


    class ExitException(BadSolutionException):
        def __init__(self, message):
            super().__init__(message)


    class UnexpectedErrorException(Exception):
        pass
  learner_created: false
- name: hstest/stage_test.py
  visible: false
  text: |
    import sys
    import runpy
    import os
    import io
    import importlib
    import signal
    import builtins
    import traceback
    from typing import List, Any, Dict
    from hstest.test_helper import *
    from hstest.test_case import TestCase
    from hstest.check_result import CheckResult
    from hstest.exceptions import *


    class StageTest:

        real_stdin = None
        real_print = None
        real_input = None
        user_output: io.StringIO = None

        @staticmethod
        def remove_kill_methods():
            os.kill = lambda *x, **y: exit(0)
            os._exit = lambda *x, **y: exit(0)
            os.killpg = lambda *x, **y: exit(0)
            signal.pthread_kill = lambda *x, **y: exit(0)
            signal.siginterrupt = lambda *x, **y: exit(0)

        @staticmethod
        def set_input(user_input: str):
            sys.stdin = io.StringIO(user_input)

        @staticmethod
        def add_input(user_input: str):
            sys.stdin: io.StringIO
            curr_position = sys.stdin.seek(0, io.SEEK_CUR)
            sys.stdin.seek(0)
            sys.stdin = io.StringIO(sys.stdin.read() + user_input)
            sys.stdin.seek(curr_position)

        @staticmethod
        def print(*args, **kwargs):
            StageTest.real_print(*args, **kwargs)
            StageTest.real_print(*args, **kwargs, file=StageTest.user_output)

        @staticmethod
        def input(arg=''):
            StageTest.print(arg, end='')
            user_input = StageTest.real_input()
            # StageTest.print()
            return user_input

        @staticmethod
        def replace_globals():
            StageTest.real_stdin = sys.stdin
            StageTest.real_print = builtins.print
            StageTest.real_input = builtins.input
            builtins.print = StageTest.print
            builtins.input = StageTest.input

        @staticmethod
        def get_print_back():
            builtins.print = StageTest.real_print
            sys.stdin = StageTest.real_stdin

        def __init__(self, module_to_test: str):
            self.remove_kill_methods()
            self.replace_globals()
            self.module_to_test = module_to_test
            self.this_test_file = __file__
            self.file_to_test = module_to_test.replace('.', os.sep) + '.py'
            self.full_file_to_test = ''
            self.tests: List[TestCase] = []

        def reset(self):
            StageTest.user_output = io.StringIO()
            top_module = self.module_to_test[:self.module_to_test.index('.')]
            for name, module in list(sys.modules.items()):
                if name.startswith(top_module):
                    importlib.reload(module)

        @staticmethod
        def create_files(files: Dict[str, str]):
            for file, content in files.items():
                with open(file, 'w') as f:
                    f.write(content)

        @staticmethod
        def delete_files(files: Dict[str, str]):
            for file in files.keys():
                if os.path.isfile(file):
                    os.remove(file)

        def run(self):
            runpy.run_module(
                self.module_to_test,
                run_name="__main__"
            )

        def test(self, test_case: TestCase) -> str:
            self.reset()
            try:
                self.create_files(test_case.files)
                sys.argv = [self.file_to_test] + test_case.args
                self.set_input(test_case.input)
                self.run()
                self.delete_files(test_case.files)
                return StageTest.user_output.getvalue()

            except SyntaxError as e:

                file = e.filename
                file = file.replace(os.sep, '.')
                file = file[file.index(self.module_to_test):-3]
                file = file.replace('.', os.sep) + '.py'

                output = f'File "{file}", line {e.lineno}\n' \
                         + e.text.strip()[: e.offset-1] + '\n' \
                         'SyntaxError: invalid syntax'

                # '`' * (e.offset - 2) + '^'

                raise SyntaxException(output)

            except (SystemExit, KeyboardInterrupt):
                raise ExitException('Tried to exit.')

        def generate(self) -> List[TestCase]:
            raise NotImplemented

        def check(self, reply: str, attach: Any) -> CheckResult:
            raise NotImplemented

        def after_all_tests(self):
            pass

        def get_stacktrace(self, hide_internals, skipped_traces=0):

            if self.full_file_to_test != '':
                common_prefix = os.path.commonpath([
                    self.full_file_to_test, self.this_test_file
                ])
            else:
                common_prefix = ''

            exc_type, exc_obj, exc_tb = sys.exc_info()

            if hide_internals and skipped_traces != 0:
                traceback_msg = 'Traceback (most recent call last):\n'
            else:
                traceback_msg = ''

            for line in traceback.TracebackException(
                    type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):
                if not hide_internals:
                    traceback_msg += line
                elif skipped_traces >= 0:
                    skipped_traces -= 1
                elif self.this_test_file not in line:
                    traceback_msg += line.replace(common_prefix + os.sep, '')

            return traceback_msg

        def run_tests(self):

            test_number = 0
            try:
                for test in self.generate():
                    test_number += 1
                    reply = self.test(test)
                    result = self.check(reply, test.attach)
                    if not result.result:
                        fail_msg = f'Wrong answer in test #{test_number}'
                        self.get_print_back()
                        failed(fail_msg + '\n\n' + result.feedback)
                        break
                passed()

            except SyntaxException as ex:
                self.get_print_back()
                failed(ex.message)

            except ExitException as ex:
                error_msg = f'Error in test #{test_number}'
                self.get_print_back()
                failed(error_msg + '\n\n' + ex.message)

            except Exception:

                exc_type, exc_obj, exc_tb = sys.exc_info()
                trace_frames = []

                user_trace_started = False
                skipped_traces = 0
                while exc_tb is not None:
                    code = exc_tb.tb_frame.f_code
                    filename = code.co_filename

                    if filename.endswith(self.file_to_test) and not user_trace_started:
                        user_trace_started = True
                        self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename

                    if user_trace_started:
                        trace_frames += [exc_tb.tb_frame.f_code]
                    else:
                        skipped_traces += 1

                    exc_tb = exc_tb.tb_next

                if not trace_frames:
                    exception_msg = (
                            f"Fatal error in test #{test_number}, " +
                            "please send the report to Hyperskill team."
                    )
                    stacktrace = self.get_stacktrace(hide_internals=False)

                else:
                    exception_msg = f'Exception in test #{test_number}'
                    stacktrace = self.get_stacktrace(
                        hide_internals=True,
                        skipped_traces=skipped_traces
                    )

                self.get_print_back()
                failed(exception_msg + '\n\n' + stacktrace)
            finally:
                self.after_all_tests()
  learner_created: false
- name: hstest/django_test.py
  visible: false
  text: |-
    import os
    import shutil
    import signal
    import subprocess
    import sys
    from time import sleep
    from urllib.error import URLError, HTTPError
    from urllib.request import urlopen
    from hstest.stage_test import StageTest
    from hstest.check_result import CheckResult
    from hstest.exceptions import UnexpectedErrorException


    EMPTY_DATABASE = 'empty.sqlite3'
    TEST_DATABASE = 'db.test.sqlite3'


    class DjangoTest(StageTest):
        _kill = os.kill
        port = '0'
        tryout_ports = ['8000', '8001', '8002', '8003', '8004']
        process = None

        def run(self):
            if self.process is None:
                self.__find_free_port()
                self.__prepare_database()
                self.process = subprocess.Popen([
                    sys.executable, self.file_to_test,
                    'runserver', self.port, '--noreload',
                ])

        def __prepare_database(self):
            if os.path.exists(EMPTY_DATABASE):
                shutil.copyfile(EMPTY_DATABASE, TEST_DATABASE)
                os.environ['HYPERSKILL_TEST_DATABASE'] = TEST_DATABASE
                migrate = subprocess.Popen(
                    [sys.executable, self.file_to_test, 'migrate'],
                    stderr=subprocess.PIPE
                )
                exit_code = migrate.wait()
                if exit_code != 0:
                    raise UnexpectedErrorException(migrate.stderr.read().decode())

        def check_server(self):
            if self.port == '0':
                return CheckResult.false(
                    f'Please free one of the ports: {", ".join(self.tryout_ports)}'
                )

            for _ in range(15):
                try:
                    urlopen(f'http://localhost:{self.port}/not-existing-link-by-default')
                    return CheckResult.true()
                except URLError as err:
                    if isinstance(err, HTTPError):
                        return CheckResult.true()
                    sleep(1)
            else:
                return CheckResult.false(
                    'Cannot start the ./manage.py runserver for 15 seconds'
                )

        def __find_free_port(self):
            for port in self.tryout_ports:
                try:
                    urlopen(f'http://localhost:{port}')
                except URLError as err:
                    if isinstance(err.reason, ConnectionRefusedError):
                        self.port = port
                        break
                except ConnectionResetError:
                    pass

        def read_page(self, link: str) -> str:
            return urlopen(link).read().decode().replace('\u00a0', ' ')

        def after_all_tests(self):
            if self.process is not None:
                try:
                    self._kill(self.process.pid, signal.SIGINT)
                except ProcessLookupError:
                    pass
  learner_created: false
- name: hstest/test_helper.py
  visible: false
  text: |2

    def set_congratulation_message(message):
        """ Overrides default 'Congratulations!' message """
        print("#educational_plugin CONGRATS_MESSAGE " + message)


    def failed(message: str):
        """ Reports failure """
        lines = message.splitlines()
        print("\n#educational_plugin FAILED + " + lines[0])
        for line in lines[1:]:
            print("#educational_plugin " + line)


    def passed():
        """ Reports success """
        print("#educational_plugin test OK")
  learner_created: false
- name: hstest/check_result.py
  visible: false
  text: |
    class CheckResult:

        def __init__(self, result: bool, feedback: str):
            self.result = result
            self.feedback = feedback

        @staticmethod
        def true():
            return CheckResult(True, '')

        @staticmethod
        def false(feedback: str = ''):
            return CheckResult(False, feedback)


    def wrong(feedback: str = '') -> CheckResult:
        return CheckResult.false(feedback)


    def accept():
        return CheckResult.true()
  learner_created: false
- name: test_video.mp4
  visible: false
  learner_created: false
feedback_link: https://hyperskill.org/projects/131/stages/701/implement#comment
status: Unchecked
record: -1
